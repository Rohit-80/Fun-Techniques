#include <bits/stdc++.h>
using namespace std;


using   ll =         long long   ;
#define All(x)       sort(x.begin(), x.end());
#define all(x)       reverse(x.begin(),x.end());
#define A_ll(x)      x.begin(),x.end()
#define endl         "\n";
#define nl           cout<<"\n";
#define work         cout<<"work"<<endl;
#define show(x)      { for(auto a  : x) cout<<a<<" "; cout<<endl;}
#define rep(a,b,c)   for(int a = b ; a < c; a++)
#define sz(x)        to_string(x).length()

typedef vector<ll> vll ;
typedef vector<int> vi ;
/*---------------------[DEBUG TEMPLATE]-------------------------------------------------------------------------------------------------------*/

template < typename T_container, typename T = typename enable_if < !is_same<T_container, string>::value, typename T_container::value_type >::type >
istream & operator >> (istream &is, T_container &v) {
    for (T &x : v) is >> x; return is;
}
#ifdef __SIZEOF_INT128__
ostream& operator << (ostream &os, __int128 const& value) {
    static char buffer[64];
    int index = 0;
    __uint128_t T = (value < 0) ? (-(value + 1)) + __uint128_t(1) : value;
    if (value < 0)
        os << '-';
    else if (T == 0)
        return os << '0';
    for (; T > 0; ++index) {
        buffer[index] = static_cast<char>('0' + (T % 10));
        T /= 10;
    }
    while (index > 0)
        os << buffer[--index];
    return os;
}

istream& operator >> (istream& is, __int128& T) {
    static char buffer[64];
    is >> buffer;
    size_t len = strlen(buffer), index = 0;
    T = 0; int mul = 1;
    if (buffer[index] == '-')
        ++index, mul *= -1;
    for (; index < len; ++index)
        T = T * 10 + static_cast<int>(buffer[index] - '0');
    T *= mul;
    return is;
}
#endif
template<typename A, typename B>
ostream& operator<<(ostream &os, const pair<A, B> &p) {
    return os << '(' << p.first << "," << p.second << ')' ;
}
template < typename T_container, typename T = typename enable_if < !is_same<T_container, string>::value, typename T_container::value_type >::type >
ostream & operator << (ostream &os, const T_container &v) {
    os << '{'; string sep;
    for (const T &x : v) os << sep << x, sep = ", ";
    return os << '}';
}
template<class P, class Q = vector<P>, class R = less<P> > ostream & operator << (ostream& out, priority_queue<P, Q, R> const& M) {
    static priority_queue<P, Q, R> U;
    U = M;
    out << "{ ";
    while (!U.empty())
        out << U.top() << " ", U.pop();
    return (out << "}");
}
template<class P> ostream& operator << (ostream& out, queue<P> const& M) {
    static queue<P> U;
    U = M;
    out << "{"; string sep;
    while (!U.empty()) {
        out << sep << U.front(); sep = ", "; U.pop();
    }
    return (out << "}");
}
#define TRACE
#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1) {
    cout << name << " : " << arg1 << endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args) {
    int count_open = 0, len = 1;
    for (int k = 1; ; ++k) {
        char cur = *(names + k);
        count_open += (cur == '(' ? 1 : (cur == ')' ? -1 : 0));
        if (cur == ',' && count_open == 0) {
            const char* comma = names + k;
            cout.write(names, len) << " : "  << arg1 << " | ";
            __f(comma + 1, args...);
            return;
        }
        len = (cur == ' ' ? len : k + 1);
    }
}
#else
#define trace(...) 1
#endif

/*---------------------------------[SOLUTION]---------------------------*/

void dfs(int n, int u, vector<int> *edges, stack<int> &firstVis, vector<bool> &vis){
    vis[u] = true;
     for(auto a : edges[u]){
         if(!vis[a]){
              dfs(n,a,edges,firstVis,vis);
         }
     }
     firstVis.push(u);
}

void dfs2(int n, int u, vector<int> *edgesT, stack<int> &firstVis, vector<bool> &vis, unordered_set<int> &comp){
    comp.insert(u);
    vis[u] = true;
     for(auto a : edgesT[u]){
         if(!vis[a]){
              dfs2(n,a,edgesT,firstVis,vis,comp);
         }
     }
     
}

vector<unordered_set<int>> scc(int n,vector<int> *edges, vector<int> * edgesT,stack<int> &firstVis){


      vector<bool> vis(n,0);

      for(int i =0 ; i < n; i++){
         if(!vis[i]){
            dfs(n,i,edges,firstVis,vis);
         }
      }
      rep(i,0,n) vis[i] = false;
     vector<unordered_set<int>> st;
   
     // trace(firstVis);

    
      
        while(!firstVis.empty()){
            int i = firstVis.top();
            firstVis.pop();
              unordered_set<int> comp;
          if(!vis[i]){

            dfs2(n,i,edgesT,firstVis,vis,comp);
         }
         st.push_back(comp);
         // trace(comp);
         // comp.clear();
      }
      
      return st;
}


void test(){

    int n,m; cin>>n>>m;
     vector<int> *edges = new vector<int> [n];
     vector<int> *edgesT = new vector<int> [n];

     rep(i,0,m){
         int u,v; cin>>u>>v;
         edges[u].push_back(v);
         edgesT[v].push_back(u);
     }

    
    stack<int> firstVis;
    
     vector<unordered_set<int>> st = scc(n,edges,edgesT,firstVis);
      // trace(st);
     for(auto a : st){
        if(a.size() != 0){
         for(auto b : a){
             cout<<b<<" ";
         }
         cout<<endl;}
      }
        delete edges;
        delete edgesT;


     
}

int main() {

    ios_base::sync_with_stdio(false); cin.tie(NULL);
    auto start = std::chrono::high_resolution_clock::now();
    
    ll t = 1;
    cin>>t;
    while (t--)
        test();

    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
    cerr << "T_taken : " << ((long double)duration.count()) / ((long double) 1e9) << "s " << endl;
    return 0;
}